{
    "docs": [
        {
            "location": "/",
            "text": "\ufeff# nise (\u507d)\n\n\nfake XHR and Server\n\n\nThis module has been extracted from \nSinon.JS\n and can be used standalone. Sinon.JS will always be the \"full package\". However, there are use cases, where fake XHR and fake Server are needed but the rest of Sinon.JS not. That's the scenario of nise.\n\n\nFake \nXMLHttpRequest\n\n\nProvides a fake implementation of \nXMLHttpRequest\n and provides\nseveral interfaces for manipulating objects created by it.\n\n\nAlso fakes native \nXMLHttpRequest\n and \nActiveXObject\n (when available, and only for \nXMLHTTP\n progids). Helps with testing requests made with \nXHR\n.\n\n\nvar fakeXhr = require(\"nise\").fakeXhr;\nvar sinon = require(\"sinon\");\n\n{\n    setUp: function () {\n        this.xhr = fakeXhr.useFakeXMLHttpRequest();\n        var requests = this.requests = [];\n\n        this.xhr.onCreate = function (xhr) {\n            requests.push(xhr);\n        };\n    },\n\n    tearDown: function () {\n        this.xhr.restore();\n    },\n\n    \"test should fetch comments from server\" : function () {\n        var callback = sinon.spy();\n        myLib.getCommentsFor(\"/some/article\", callback);\n        assertEquals(1, this.requests.length);\n\n        this.requests[0].respond(200, { \"Content-Type\": \"application/json\" },\n                                 '[{ \"id\": 12, \"comment\": \"Hey there\" }]');\n        assert(callback.calledWith([{ id: 12, comment: \"Hey there\" }]));\n    }\n}\n\n\n\n\nuseFakeXMLHttpRequest\n\n\nvar xhr = fakeXhr.useFakeXMLHttpRequest();\n\n\nCauses fakeXhr to replace the native \nXMLHttpRequest\n object in browsers that support it with a custom implementation which does not send actual requests.\n\n\nIn browsers that support \nActiveXObject\n, this constructor is replaced, and fake objects are returned for \nXMLHTTP\n progIds. Other progIds, such as \nXMLDOM\n are left untouched.\n\n\nThe native \nXMLHttpRequest\n object will be available at \nfakeXhr.xhr.XMLHttpRequest\n\n\nxhr.onCreate = function (xhr) {};\n\n\nBy assigning a function to the \nonCreate\n property of the returned object from \nuseFakeXMLHttpRequest()\n you can subscribe to newly created \nFakeXMLHttpRequest\n objects. See below for the fake xhr object API.\n\n\nUsing this observer means you can still reach objects created by e.g. \njQuery.ajax\n (or other abstractions/frameworks).\n\n\nxhr.restore();\n\n\nRestore original function(s).\n\n\nFakeXMLHttpRequest\n\n\nString request.url\n\n\nThe URL set on the request object.\n\n\nString request.method\n\n\nThe request method as a string.\n\n\nObject request.requestHeaders\n\n\nAn object of all request headers, i.e.:\n\n\n{\n    \"Accept\": \"text/html, */*\",\n    \"Connection\": \"keep-alive\"\n}\n\n\n\n\nString request.requestBody\n\n\nThe request body\n\n\nint request.status\n\n\nThe request's status code.\n\n\nundefined\n if the request has not been handled (see \nrespond\n below)\n\n\nString request.statusText\n\n\nOnly populated if the \nrespond\n method is called (see below).\n\n\nboolean request.async\n\n\nWhether or not the request is asynchronous.\n\n\nString request.username\n\n\nUsername, if any.\n\n\nString request.password\n\n\nPassword, if any.\n\n\nDocument request.responseXML\n\n\nWhen using \nrespond\n, this property is populated with a parsed document if response headers indicate as much (see \nthe spec\n)\n\n\nString request.getResponseHeader(header);\n\n\nThe value of the given response header, if the request has been responded to (see \nrespond\n).\n\n\nObject request.getAllResponseHeaders();\n\n\nAll response headers as an object.\n\n\nFiltered requests\n\n\nWhen using Sinon.JS for mockups or partial integration/functional testing, you might want to fake some requests, while allowing others to go through to the backend server. With filtered \nFakeXMLHttpRequest\ns (new in v1.3.0), you can.\n\n\nFakeXMLHttpRequest.useFilters\n\n\nDefault \nfalse\n.\n\n\nWhen set to \ntrue\n, Sinon will check added filters if certain requests should be \"unfaked\"\n\n\nFakeXMLHttpRequest.addFilter(fn)\n\n\nAdd a filter that will decide whether or not to fake a request.\n\n\nThe filter will be called when \nxhr.open\n is called, with the exact same arguments (\nmethod\n, \nurl\n, \nasync\n, \nusername\n, \npassword\n). If the filter returns \ntrue\n, the request will not be faked.\n\n\nSimulating server responses\n\n\nrequest.setStatus(status);\n\n\nSets response status (\nstatus\n and \nstatusText\n properties).\n\n\nStatus should be a number, the status text is looked up from \nfakeXhr.FakeXMLHttpRequest.statusCodes\n.\n\n\nrequest.setResponseHeaders(object);\n\n\nSets response headers (e.g. \n{ \"Content-Type\": \"text/html\", /* ... */ }\n, updates the \nreadyState\n property and fires \nonreadystatechange\n.\n\n\nrequest.setResponseBody(body);\n\n\nSets the respond body, updates the \nreadyState\n property and fires \nonreadystatechange\n.\n\n\nAdditionally, populates \nresponseXML\n with a parsed document if \nresponse headers indicate as much\n.\n\n\nrequest.respond(status, headers, body);\n\n\nCalls the above three methods.\n\n\nrequest.error();\n\n\nSimulates a network error on the request. The \nonerror\n handler will be called and the \nstatus\n will be \n0\n.\n\n\nBoolean request.autoRespond\n\n\nWhen set to \ntrue\n, causes the server to automatically respond to incoming requests after a timeout.\n\n\nThe default timeout is 10ms but you can control it through the \nautoRespondAfter\n property.\n\n\nNote that this feature is intended to help during mockup development, and is not suitable for use in tests.\n\n\nNumber request.autoRespondAfter\n\n\nWhen \nautoRespond\n is \ntrue\n, respond to requests after this number of milliseconds. Default is 10.\n\n\nFake server\n\n\nHigh-level API to manipulate \nFakeXMLHttpRequest\n instances.\n\n\nFor help with handling JSON-P please refer to our \nnotes below\n\n\nvar fakeServer = require(\"nise\").fakeServer;\nvar sinon = require(\"sinon\");\n\n{\n    setUp: function () {\n        this.server = fakeServer.create();\n    },\n\n    tearDown: function () {\n        this.server.restore();\n    },\n\n    \"test should fetch comments from server\" : function () {\n        this.server.respondWith(\"GET\", \"/some/article/comments.json\",\n            [200, { \"Content-Type\": \"application/json\" },\n             '[{ \"id\": 12, \"comment\": \"Hey there\" }]']);\n\n        var callback = sinon.spy();\n        myLib.getCommentsFor(\"/some/article\", callback);\n        this.server.respond();\n\n        sinon.assert.calledWith(callback, [{ id: 12, comment: \"Hey there\" }]);\n\n        assert(server.requests.length > 0)\n    }\n}\n\n\n\n\nvar server = fakeServer.create([config]);\n\n\nCreates a new server.\n\n\nThis function also calls \nuseFakeXMLHttpRequest()\n.\n\n\ncreate\n accepts optional properties to configure the fake server. See \noptions\n below for configuration parameters.\n\n\nvar server = fakeServerWithClock.create();\n\n\nCreates a server that also manages fake timers.\n\n\nThis is useful when testing \nXHR\n objects created with e.g. jQuery 1.3.x, which uses a timer to poll the object for completion, rather than the usual \nonreadystatechange\n.\n\n\nserver.configure(config);\n\n\nConfigures the fake server.\n\n\nSee \noptions\n below for configuration parameters.\n\n\nserver.respondWith(response);\n\n\nCauses the server to respond to any request not matched by another response with the provided data. The default catch-all response is \n[404, {}, \"\"]\n.\n\n\nresponse\n can be one of three things:\n\n\n\n\nA \nString\n or \nArrayBuffer\n representing the response body\n\n\nAn \nArray\n with status, headers and response body, e.g. \n[200, { \"Content-Type\": \"text/html\", \"Content-Length\": 2 }, \"OK\"]\n\n\nA \nFunction\n.\n\n\n\n\nDefault status is 200 and default headers are none.\n\n\nWhen the response is a \nFunction\n, it will be passed the request object. You\nmust manually call \nrespond\n on it to complete the\nrequest.\n\n\nserver.respondWith(url, response);\n\n\nResponds to all requests to given URL, e.g. \n/posts/1\n.\n\n\nserver.respondWith(method, url, response);\n\n\nResponds to all \nmethod\n requests to the given URL with the given response.\n\n\nmethod\n is an HTTP verb.\n\n\nserver.respondWith(urlRegExp, response);\n\n\nURL may be a regular expression, e.g. \n/\\\\/post\\\\//\\\\d+\n\n\nIf the response is a \nFunction\n, it will be passed any capture groups from the regular expression along with the XMLHttpRequest object:\n\n\nserver.respondWith(/\\/todo-items\\/(\\d+)/, function (xhr, id) {\n    xhr.respond(200, { \"Content-Type\": \"application/json\" }, '[{ \"id\": ' + id + \" }]\");\n});\n\n\n\n\nserver.respondWith(method, urlRegExp, response);\n\n\nResponds to all \nmethod\n requests to URLs matching the regular expression.\n\n\nserver.respond();\n\n\nCauses all queued asynchronous requests to receive a response.\n\n\nIf none of the responses added through \nrespondWith\n match, the default response is \n[404, {}, \"\"]\n.\n\n\nSynchronous requests are responded to immediately, so make sure to call \nrespondWith\n upfront.\n\n\nIf called with arguments, \nrespondWith\n will be called with those arguments before responding to requests.\n\n\nserver.autoRespond = true;\n\n\nIf set, will automatically respond to every request after a timeout.\n\n\nThe default timeout is 10ms but you can control it through the \nautoRespondAfter\n property.\n\n\nNote that this feature is intended to help during mockup development, and is not suitable for use in tests. For synchronous immediate responses, use \nrespondImmediately\n instead.\n\n\nserver.autoRespondAfter = ms;\n\n\nCauses the server to automatically respond to incoming requests after a timeout.\n\n\nserver.respondImmediately = true;\n\n\nIf set, the server will respond to every request immediately and synchronously.\n\n\nThis is ideal for faking the server from within a test without having to call \nserver.respond()\n after each request made in that test.\n\n\nAs this is synchronous and immediate, this is not suitable for simulating actual network latency in tests or mockups. To simulate network latency with automatic responses, see \nserver.autoRespond\n and \nserver.autoRespondAfter\n.\n\n\narray \nserver.requests\n\n\nYou can inspect the \nserver.requests\n to verify request ordering, find unmatched requests or check that no requests has been done.\n\nserver.requests\n is an array of all the \nFakeXMLHttpRequest\n objects that have been created.\n\n\nBoolean server.fakeHTTPMethods\n\n\nIf set to \ntrue\n, server will find \n_method\n parameter in POST body and recognize that as the actual method.\n\n\nSupports a pattern common to Ruby on Rails applications. For custom HTTP method faking, override \nserver.getHTTPMethod(request)\n.\n\n\nserver.getHTTPMethod(request)\n\n\nUsed internally to determine the HTTP method used with the provided request.\n\n\nBy default this method simply returns \nrequest.method\n. When \nserver.fakeHTTPMethods\n is true, the method will return the value of the \n_method\n parameter if the method is \"POST\".\n\n\nThis method can be overridden to provide custom behavior.\n\n\nserver.restore();\n\n\nRestores the native XHR constructor.\n\n\nFake server options\n\n\nThese options are properties on the server object and can be set directly\n\n\nserver.autoRespond = true\n\n\n\n\nYou can also pass options with an object literal to \nfakeServer.create\n and \n.configure\n.\n\n\nBoolean autoRespond\n\n\nIf set, will automatically respond to every request after a timeout.\n\n\nThe default timeout is 10ms but you can control it through the \nautoRespondAfter\n property.\n\n\nNote that this feature is intended to help during mockup development, and is not suitable for use in tests.\n\n\nFor synchronous immediate responses, use \nrespondImmediately\n instead.\n\n\nNumber autoRespondAfter (ms)\n\n\nCauses the server to automatically respond to incoming requests after a timeout.\n\n\nBoolean respondImmediately\n\n\nIf set, the server will respond to every request immediately and synchronously.\n\n\nThis is ideal for faking the server from within a test without having to call \nserver.respond()\n after each request made in that test.\n\n\nAs this is synchronous and immediate, this is not suitable for simulating actual network latency in tests or mockups. To simulate network latency with automatic responses, see \nserver.autoRespond\n and \nserver.autoRespondAfter\n.\n\n\nboolean fakeHTTPMethods\n\n\nIf set to \ntrue\n, server will find \n_method\n parameter in \nPOST\n body and recognize that as the actual method.\n\n\nSupports a pattern common to Ruby on Rails applications.\n\n\nFor custom HTTP method faking, override \nserver.getHTTPMethod(request)",
            "title": "Home"
        },
        {
            "location": "/#fake-xmlhttprequest",
            "text": "Provides a fake implementation of  XMLHttpRequest  and provides\nseveral interfaces for manipulating objects created by it.  Also fakes native  XMLHttpRequest  and  ActiveXObject  (when available, and only for  XMLHTTP  progids). Helps with testing requests made with  XHR .  var fakeXhr = require(\"nise\").fakeXhr;\nvar sinon = require(\"sinon\");\n\n{\n    setUp: function () {\n        this.xhr = fakeXhr.useFakeXMLHttpRequest();\n        var requests = this.requests = [];\n\n        this.xhr.onCreate = function (xhr) {\n            requests.push(xhr);\n        };\n    },\n\n    tearDown: function () {\n        this.xhr.restore();\n    },\n\n    \"test should fetch comments from server\" : function () {\n        var callback = sinon.spy();\n        myLib.getCommentsFor(\"/some/article\", callback);\n        assertEquals(1, this.requests.length);\n\n        this.requests[0].respond(200, { \"Content-Type\": \"application/json\" },\n                                 '[{ \"id\": 12, \"comment\": \"Hey there\" }]');\n        assert(callback.calledWith([{ id: 12, comment: \"Hey there\" }]));\n    }\n}",
            "title": "Fake XMLHttpRequest"
        },
        {
            "location": "/#usefakexmlhttprequest",
            "text": "",
            "title": "useFakeXMLHttpRequest"
        },
        {
            "location": "/#var-xhr-fakexhrusefakexmlhttprequest",
            "text": "Causes fakeXhr to replace the native  XMLHttpRequest  object in browsers that support it with a custom implementation which does not send actual requests.  In browsers that support  ActiveXObject , this constructor is replaced, and fake objects are returned for  XMLHTTP  progIds. Other progIds, such as  XMLDOM  are left untouched.  The native  XMLHttpRequest  object will be available at  fakeXhr.xhr.XMLHttpRequest",
            "title": "var xhr = fakeXhr.useFakeXMLHttpRequest();"
        },
        {
            "location": "/#xhroncreate-function-xhr",
            "text": "By assigning a function to the  onCreate  property of the returned object from  useFakeXMLHttpRequest()  you can subscribe to newly created  FakeXMLHttpRequest  objects. See below for the fake xhr object API.  Using this observer means you can still reach objects created by e.g.  jQuery.ajax  (or other abstractions/frameworks).",
            "title": "xhr.onCreate = function (xhr) {};"
        },
        {
            "location": "/#xhrrestore",
            "text": "Restore original function(s).",
            "title": "xhr.restore();"
        },
        {
            "location": "/#fakexmlhttprequest",
            "text": "",
            "title": "FakeXMLHttpRequest"
        },
        {
            "location": "/#string-requesturl",
            "text": "The URL set on the request object.",
            "title": "String request.url"
        },
        {
            "location": "/#string-requestmethod",
            "text": "The request method as a string.",
            "title": "String request.method"
        },
        {
            "location": "/#object-requestrequestheaders",
            "text": "An object of all request headers, i.e.:  {\n    \"Accept\": \"text/html, */*\",\n    \"Connection\": \"keep-alive\"\n}",
            "title": "Object request.requestHeaders"
        },
        {
            "location": "/#string-requestrequestbody",
            "text": "The request body",
            "title": "String request.requestBody"
        },
        {
            "location": "/#int-requeststatus",
            "text": "The request's status code.  undefined  if the request has not been handled (see  respond  below)",
            "title": "int request.status"
        },
        {
            "location": "/#string-requeststatustext",
            "text": "Only populated if the  respond  method is called (see below).",
            "title": "String request.statusText"
        },
        {
            "location": "/#boolean-requestasync",
            "text": "Whether or not the request is asynchronous.",
            "title": "boolean request.async"
        },
        {
            "location": "/#string-requestusername",
            "text": "Username, if any.",
            "title": "String request.username"
        },
        {
            "location": "/#string-requestpassword",
            "text": "Password, if any.",
            "title": "String request.password"
        },
        {
            "location": "/#document-requestresponsexml",
            "text": "When using  respond , this property is populated with a parsed document if response headers indicate as much (see  the spec )",
            "title": "Document request.responseXML"
        },
        {
            "location": "/#string-requestgetresponseheaderheader",
            "text": "The value of the given response header, if the request has been responded to (see  respond ).",
            "title": "String request.getResponseHeader(header);"
        },
        {
            "location": "/#object-requestgetallresponseheaders",
            "text": "All response headers as an object.",
            "title": "Object request.getAllResponseHeaders();"
        },
        {
            "location": "/#filtered-requests",
            "text": "When using Sinon.JS for mockups or partial integration/functional testing, you might want to fake some requests, while allowing others to go through to the backend server. With filtered  FakeXMLHttpRequest s (new in v1.3.0), you can.",
            "title": "Filtered requests"
        },
        {
            "location": "/#fakexmlhttprequestusefilters",
            "text": "Default  false .  When set to  true , Sinon will check added filters if certain requests should be \"unfaked\"",
            "title": "FakeXMLHttpRequest.useFilters"
        },
        {
            "location": "/#fakexmlhttprequestaddfilterfn",
            "text": "Add a filter that will decide whether or not to fake a request.  The filter will be called when  xhr.open  is called, with the exact same arguments ( method ,  url ,  async ,  username ,  password ). If the filter returns  true , the request will not be faked.",
            "title": "FakeXMLHttpRequest.addFilter(fn)"
        },
        {
            "location": "/#simulating-server-responses",
            "text": "",
            "title": "Simulating server responses"
        },
        {
            "location": "/#requestsetstatusstatus",
            "text": "Sets response status ( status  and  statusText  properties).  Status should be a number, the status text is looked up from  fakeXhr.FakeXMLHttpRequest.statusCodes .",
            "title": "request.setStatus(status);"
        },
        {
            "location": "/#requestsetresponseheadersobject",
            "text": "Sets response headers (e.g.  { \"Content-Type\": \"text/html\", /* ... */ } , updates the  readyState  property and fires  onreadystatechange .",
            "title": "request.setResponseHeaders(object);"
        },
        {
            "location": "/#requestsetresponsebodybody",
            "text": "Sets the respond body, updates the  readyState  property and fires  onreadystatechange .  Additionally, populates  responseXML  with a parsed document if  response headers indicate as much .",
            "title": "request.setResponseBody(body);"
        },
        {
            "location": "/#requestrespondstatus-headers-body",
            "text": "Calls the above three methods.",
            "title": "request.respond(status, headers, body);"
        },
        {
            "location": "/#requesterror",
            "text": "Simulates a network error on the request. The  onerror  handler will be called and the  status  will be  0 .",
            "title": "request.error();"
        },
        {
            "location": "/#boolean-requestautorespond",
            "text": "When set to  true , causes the server to automatically respond to incoming requests after a timeout.  The default timeout is 10ms but you can control it through the  autoRespondAfter  property.  Note that this feature is intended to help during mockup development, and is not suitable for use in tests.",
            "title": "Boolean request.autoRespond"
        },
        {
            "location": "/#number-requestautorespondafter",
            "text": "When  autoRespond  is  true , respond to requests after this number of milliseconds. Default is 10.",
            "title": "Number request.autoRespondAfter"
        },
        {
            "location": "/#fake-server",
            "text": "High-level API to manipulate  FakeXMLHttpRequest  instances.  For help with handling JSON-P please refer to our  notes below  var fakeServer = require(\"nise\").fakeServer;\nvar sinon = require(\"sinon\");\n\n{\n    setUp: function () {\n        this.server = fakeServer.create();\n    },\n\n    tearDown: function () {\n        this.server.restore();\n    },\n\n    \"test should fetch comments from server\" : function () {\n        this.server.respondWith(\"GET\", \"/some/article/comments.json\",\n            [200, { \"Content-Type\": \"application/json\" },\n             '[{ \"id\": 12, \"comment\": \"Hey there\" }]']);\n\n        var callback = sinon.spy();\n        myLib.getCommentsFor(\"/some/article\", callback);\n        this.server.respond();\n\n        sinon.assert.calledWith(callback, [{ id: 12, comment: \"Hey there\" }]);\n\n        assert(server.requests.length > 0)\n    }\n}",
            "title": "Fake server"
        },
        {
            "location": "/#var-server-fakeservercreateconfig",
            "text": "Creates a new server.  This function also calls  useFakeXMLHttpRequest() .  create  accepts optional properties to configure the fake server. See  options  below for configuration parameters.",
            "title": "var server = fakeServer.create([config]);"
        },
        {
            "location": "/#var-server-fakeserverwithclockcreate",
            "text": "Creates a server that also manages fake timers.  This is useful when testing  XHR  objects created with e.g. jQuery 1.3.x, which uses a timer to poll the object for completion, rather than the usual  onreadystatechange .",
            "title": "var server = fakeServerWithClock.create();"
        },
        {
            "location": "/#serverconfigureconfig",
            "text": "Configures the fake server.  See  options  below for configuration parameters.",
            "title": "server.configure(config);"
        },
        {
            "location": "/#serverrespondwithresponse",
            "text": "Causes the server to respond to any request not matched by another response with the provided data. The default catch-all response is  [404, {}, \"\"] .  response  can be one of three things:   A  String  or  ArrayBuffer  representing the response body  An  Array  with status, headers and response body, e.g.  [200, { \"Content-Type\": \"text/html\", \"Content-Length\": 2 }, \"OK\"]  A  Function .   Default status is 200 and default headers are none.  When the response is a  Function , it will be passed the request object. You\nmust manually call  respond  on it to complete the\nrequest.",
            "title": "server.respondWith(response);"
        },
        {
            "location": "/#serverrespondwithurl-response",
            "text": "Responds to all requests to given URL, e.g.  /posts/1 .",
            "title": "server.respondWith(url, response);"
        },
        {
            "location": "/#serverrespondwithmethod-url-response",
            "text": "Responds to all  method  requests to the given URL with the given response.  method  is an HTTP verb.",
            "title": "server.respondWith(method, url, response);"
        },
        {
            "location": "/#serverrespondwithurlregexp-response",
            "text": "URL may be a regular expression, e.g.  /\\\\/post\\\\//\\\\d+  If the response is a  Function , it will be passed any capture groups from the regular expression along with the XMLHttpRequest object:  server.respondWith(/\\/todo-items\\/(\\d+)/, function (xhr, id) {\n    xhr.respond(200, { \"Content-Type\": \"application/json\" }, '[{ \"id\": ' + id + \" }]\");\n});",
            "title": "server.respondWith(urlRegExp, response);"
        },
        {
            "location": "/#serverrespondwithmethod-urlregexp-response",
            "text": "Responds to all  method  requests to URLs matching the regular expression.",
            "title": "server.respondWith(method, urlRegExp, response);"
        },
        {
            "location": "/#serverrespond",
            "text": "Causes all queued asynchronous requests to receive a response.  If none of the responses added through  respondWith  match, the default response is  [404, {}, \"\"] .  Synchronous requests are responded to immediately, so make sure to call  respondWith  upfront.  If called with arguments,  respondWith  will be called with those arguments before responding to requests.",
            "title": "server.respond();"
        },
        {
            "location": "/#serverautorespond-true",
            "text": "If set, will automatically respond to every request after a timeout.  The default timeout is 10ms but you can control it through the  autoRespondAfter  property.  Note that this feature is intended to help during mockup development, and is not suitable for use in tests. For synchronous immediate responses, use  respondImmediately  instead.",
            "title": "server.autoRespond = true;"
        },
        {
            "location": "/#serverautorespondafter-ms",
            "text": "Causes the server to automatically respond to incoming requests after a timeout.",
            "title": "server.autoRespondAfter = ms;"
        },
        {
            "location": "/#serverrespondimmediately-true",
            "text": "If set, the server will respond to every request immediately and synchronously.  This is ideal for faking the server from within a test without having to call  server.respond()  after each request made in that test.  As this is synchronous and immediate, this is not suitable for simulating actual network latency in tests or mockups. To simulate network latency with automatic responses, see  server.autoRespond  and  server.autoRespondAfter .",
            "title": "server.respondImmediately = true;"
        },
        {
            "location": "/#array-serverrequests",
            "text": "You can inspect the  server.requests  to verify request ordering, find unmatched requests or check that no requests has been done. server.requests  is an array of all the  FakeXMLHttpRequest  objects that have been created.",
            "title": "array server.requests"
        },
        {
            "location": "/#boolean-serverfakehttpmethods",
            "text": "If set to  true , server will find  _method  parameter in POST body and recognize that as the actual method.  Supports a pattern common to Ruby on Rails applications. For custom HTTP method faking, override  server.getHTTPMethod(request) .",
            "title": "Boolean server.fakeHTTPMethods"
        },
        {
            "location": "/#servergethttpmethodrequest",
            "text": "Used internally to determine the HTTP method used with the provided request.  By default this method simply returns  request.method . When  server.fakeHTTPMethods  is true, the method will return the value of the  _method  parameter if the method is \"POST\".  This method can be overridden to provide custom behavior.",
            "title": "server.getHTTPMethod(request)"
        },
        {
            "location": "/#serverrestore",
            "text": "Restores the native XHR constructor.",
            "title": "server.restore();"
        },
        {
            "location": "/#fake-server-options",
            "text": "These options are properties on the server object and can be set directly  server.autoRespond = true  You can also pass options with an object literal to  fakeServer.create  and  .configure .",
            "title": "Fake server options"
        },
        {
            "location": "/#boolean-autorespond",
            "text": "If set, will automatically respond to every request after a timeout.  The default timeout is 10ms but you can control it through the  autoRespondAfter  property.  Note that this feature is intended to help during mockup development, and is not suitable for use in tests.  For synchronous immediate responses, use  respondImmediately  instead.",
            "title": "Boolean autoRespond"
        },
        {
            "location": "/#number-autorespondafter-ms",
            "text": "Causes the server to automatically respond to incoming requests after a timeout.",
            "title": "Number autoRespondAfter (ms)"
        },
        {
            "location": "/#boolean-respondimmediately",
            "text": "If set, the server will respond to every request immediately and synchronously.  This is ideal for faking the server from within a test without having to call  server.respond()  after each request made in that test.  As this is synchronous and immediate, this is not suitable for simulating actual network latency in tests or mockups. To simulate network latency with automatic responses, see  server.autoRespond  and  server.autoRespondAfter .",
            "title": "Boolean respondImmediately"
        },
        {
            "location": "/#boolean-fakehttpmethods",
            "text": "If set to  true , server will find  _method  parameter in  POST  body and recognize that as the actual method.  Supports a pattern common to Ruby on Rails applications.  For custom HTTP method faking, override  server.getHTTPMethod(request)",
            "title": "boolean fakeHTTPMethods"
        }
    ]
}